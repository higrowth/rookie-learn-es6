互不侵犯的let和const命令
========================

> 前端小菜鸟的ES6学习笔记

一、 var 命令的作用域
---------------------

在ES6之前的变量声明中，我们常常使用 `var` 关键字来声明变量。但随着在一些项目中的实践，会发现出现了一些跟预期不太一样的事情。例如一个典型的例子如下：

```javascript

var arr = [];
for (var i = 0; i < 10; i++) {
  arr[i] = function () {
    console.log(i);
  };
}
arr[9]();// 10

```

本来我们预期希望数组的每一项是一个可以打印出当前项在数组中的索引的函数，但实际运行后会发现，无论我们调用数组的哪一项，最终的输出结果都是10； 这是因为`var`声明的变量`i`是全局变量，在全局范围内都有效，而且全局范围内只存在一个`i`。因此在调用数组的每一项函数时，其打印出来的`i`实际上是同一个变量，而这个变量在循环体执行完成后已经变成了10.

解决这个问题的方法很简单，只需要把`var i = 0;`改为使用`let`声明，即`let i = 0;`，就会发现得到了我们预期的效果。这就涉及到了`let`命令的作用域问题。

二、let 命令的作用域
--------------------

ES6规定，`let`用来声明变量，其与`var`的不同之处在于，`let`只在自己的块级作用域中有效。在作用域外使用`let`声明的变量，会报`undefined`错误。

在ES5中， 是只有全局作用域和函数作用域，没有块级作用域，块级作用域通俗来讲，就是`{}`包含的区域。那为什么需要块级作用域呢？因为在实际开发中，经常会出现一些不合理或者不符合预期的场景。例如：

```

```
